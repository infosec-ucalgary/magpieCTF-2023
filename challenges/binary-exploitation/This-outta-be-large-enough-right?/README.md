# This outta be large enough right?
### Category: Binary exploitation
### Author: Christina

## Description
This seems to be running on a satelite somewhere. We were able to get a copy of the program, maybe we can exploit it for a flag!

## Hints
1. This is a basic buffer overflow challenge.

## Solution
1. Looking at chall.c, you would see that there is an uncalled win function and a vulnerable gets(). Piecing these two information together, this is a basic return to win challenge.
2. First starting off by finding out the offset. You can do this in several ways. One way is to find a buffer overflow pattern generator online, putting in the sequence and then use 'sudo dmesg' to check the overflowed value showing after ip in red. Copy this value down and put it back to you buffer overflow pattern offset find to find the offset. You can also use metasploit's pattern generator or pwntool's cyclic(), up to your choice. Here the offset is 68. Without using a cyclic group, you can also figure out the offset by looking at its assembly. Here,  0x080484b8 <+4>:     sub    esp,0x44 indicated there are 68 bytes allocated between esp and ebp.
3. Then find the address of the function win() using nm (or readelf or whichever tool you'd like to use). Here the address of win is 08048486, which is \x86\x84\x04\x08 in little endian format.
4. Putting them all together, we first overflow the first 68 bits with random bytes, then appending the return address of the win function we get: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x86\x84\x04\x08
5. Pipe this payload to the program/remote server using echo -e 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x86\x84\x04\x08'|./chall (replace ./chall with nc <ip address> <port> for remote server)
Also see solve/sol.py for the solve script.

## Flag
magpie{0mn1_fl4g_3v3rywh3r3}
